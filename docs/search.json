[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advent of Code",
    "section": "",
    "text": "Julekalender\n\n\nÅrene 2015–2024 og dagene 1–25\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n\n2015\n🎅\n🎅\n🎅\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2016\n\n🎅\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2017\n🎅\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2024\n🎅\n🎅\n🎅"
  },
  {
    "objectID": "aoc2024/day-02.html",
    "href": "aoc2024/day-02.html",
    "title": "Advent of Code 2024",
    "section": "",
    "text": "As always:\n\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.5.1\n\n\nWarning: package 'tibble' was built under R version 4.5.1\n\n\nWarning: package 'purrr' was built under R version 4.5.1\n\n\nWarning: package 'stringr' was built under R version 4.5.1\n\n\nWe need to generate diffences between succesive numbers. And then check if they are all increasing, or all decreasing. And if the increase/decrease is between 1 and 3 inclusive."
  },
  {
    "objectID": "aoc2024/day-02.html#getting-running-differences",
    "href": "aoc2024/day-02.html#getting-running-differences",
    "title": "Advent of Code 2024",
    "section": "",
    "text": "As always:\n\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.5.1\n\n\nWarning: package 'tibble' was built under R version 4.5.1\n\n\nWarning: package 'purrr' was built under R version 4.5.1\n\n\nWarning: package 'stringr' was built under R version 4.5.1\n\n\nWe need to generate diffences between succesive numbers. And then check if they are all increasing, or all decreasing. And if the increase/decrease is between 1 and 3 inclusive."
  },
  {
    "objectID": "aoc2024/day-02.html#the-example",
    "href": "aoc2024/day-02.html#the-example",
    "title": "Advent of Code 2024",
    "section": "The example",
    "text": "The example\nFirst write a fuction, that, given a vector of numerics, calculates the change from element to element. It then checks if they are all increasing or decreasing. And if the absolute change is larger than 0 or smaller than 4.\n\ncheck &lt;- function(x){\n  x &lt;- c(x[-1], NA) - x\n  x &lt;- x[!is.na(x)]\n  res1 &lt;- all(sign(x) == 1) | all(sign(x) == -1) # all increasing or decreasing\n  res2 &lt;- all(abs(x) &lt; 4 & abs(x) &gt; 0)\n  res1 & res2\n}\n\nThe tricky thing was to construct the vector with the changes from element to element. And it was not that tricky.\nRather than constructing the example manually, I saved it to a txt-file.\nI read it, convert it to at tibble, split it on white spaces, and coerce it to numeric. All in a list-column:\n\nexample &lt;- readLines(\"data/day-02-example.txt\") %&gt;% \n  as_tibble() %&gt;% \n  mutate(vectors = str_split(value, \" \")) %&gt;% \n  mutate(vectors = map( vectors, as.numeric))\n\nNow we can map the check-function on the list-column, unnest it, and sum all the logical values:\n\nexample %&gt;% \n  transmute(check = map(vectors, check)) %&gt;% \n  unnest(check) %&gt;% \n  summarise(answer = sum(check))\n\n# A tibble: 1 × 1\n  answer\n   &lt;int&gt;\n1      2\n\n\n\nThe actual task\nHaving checked that the example returns the correct answer, we run it on the input. First read in the data:\n\ntask &lt;- readLines(\"data/day-02-input.txt\") %&gt;% as_tibble() %&gt;% \n  mutate(vectors = str_split(value, \" \")) %&gt;% \n  mutate(vectors = map( vectors, as.numeric))\n\nAnd now we do the exact same operations:\n\ntask %&gt;% \n  transmute(check = map(vectors, check)) %&gt;% \n  unnest(check) %&gt;% \n  summarise(answer = sum(check))\n\n# A tibble: 1 × 1\n  answer\n   &lt;int&gt;\n1    479\n\n\n\n\nPart 2\n\nThe example\nWe need to remove the first element in the vector, and check it. And to remove the second element and check that, etc.\nWe write a new function, which by default returns FALSE, but if one of the point-deletions of an element lead the vector to pass the check-function, it returns TRUE:\n\ndampener &lt;- function(x){\n  res &lt;- FALSE\n  for(i in 1:length(x)){\n    if(check(x[-i])) res &lt;- TRUE\n  }  \n  res\n}\n\nWe run that on the example:\n\nexample %&gt;% \n  transmute(check = map(vectors, dampener)) %&gt;% \n  unnest(check) %&gt;% \n  summarise(answer = sum(check))\n\n# A tibble: 1 × 1\n  answer\n   &lt;int&gt;\n1      4\n\n\n\n\nThe actual task\nWe got the correct answer, and now run the same code on the task-data:\n\ntask %&gt;%   \n  transmute(check = map(vectors, dampener)) %&gt;% \n  unnest(check) %&gt;% \n  summarise(answer = sum(check))\n\n# A tibble: 1 × 1\n  answer\n   &lt;int&gt;\n1    531\n\n\nDone 🎄"
  },
  {
    "objectID": "aoc2017/day-01.html",
    "href": "aoc2017/day-01.html",
    "title": "Advent of Code 2017",
    "section": "",
    "text": "Having a sequence of digits, one digit with the next (or, if the digit is the last, the first digit in the sequence). The digits that are the same as the next digit, are added together. Do that for a very large number.\n\n\n\n1122 produces a sum of 3 (1 + 2) because the first digit (1) matches the second digit and the third digit (2) matches the fourth digit.\n1111 produces 4 because each digit (all 1) matches the next.\n1234 produces 0 because no digit matches the next.\n91212129 produces 9 because the only digit that matches the next one is the last digit, 9.\n\nConstruct the test-cases:\n\nexample &lt;- c(\"1122\", \"1111\", \"1234\", \"91212129\")\n\nWhy a character vector? The input for the actual task might technically be a number. But it is so huge that we do not want to handle it as such.\nWe split the input, and convert to a numeric vector. Next that vector is shiftet to the right, placing the last value as the first, the first as the second etc. Then we compare those two vectors, and use that as a boolean index to the values.\n\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.5.1\n\n\nWarning: package 'tibble' was built under R version 4.5.1\n\n\nWarning: package 'purrr' was built under R version 4.5.1\n\n\nWarning: package 'stringr' was built under R version 4.5.1\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ncaptcha &lt;- function(input){\n  input &lt;- str_split_1(input, \"\") |&gt; as.numeric()\n  input_shifted &lt;- c(input[length(input)], input[2:length(input)-1])\n  sum(input[input == input_shifted])\n}\n\nTestning:\n\ncaptcha(example[4])\n\n[1] 9\n\n\nIt works.\n\n\n\nRead in the input:\n\ninput &lt;- readLines(\"data/day-01-input.txt\")\n\nUse it as input to the function:\n\ncaptcha(input)\n\n[1] 1171\n\n\nFirst star!\n\n\n\n\nNext we need to shift the vector even more. 50% in fact. This requires a new captcha function:\n\nnext_captcha &lt;- function(input){\n    input &lt;- str_split_1(input, \"\") |&gt; as.numeric()\n    len &lt;- length(input)\n    input_shifted &lt;- c(input[(len/2+1):len], input[1:(len/2)])\n    sum(input[input == input_shifted])\n  }\n\n\n\n\n1212 produces 6: the list contains 4 items, and all four digits match the digit 2 items ahead.\n1221 produces 0, because every comparison is between a 1 and a 2.\n123425 produces 4, because both 2s match each other, but no other digit has a match.\n123123 produces 12.\n12131415 produces 4.\n\nSetting up example data:\n\nexample &lt;- c(\"1212\", \"1221\", \"123425\", \"123123\", \"12131415\")\n\nTesting:\n\nnext_captcha(example[2])\n\n[1] 0\n\n\n\n\n\n\nnext_captcha(input)\n\n[1] 1024\n\n\nDone 🎄"
  },
  {
    "objectID": "aoc2017/day-01.html#shifting-and-comparing",
    "href": "aoc2017/day-01.html#shifting-and-comparing",
    "title": "Advent of Code 2017",
    "section": "",
    "text": "Having a sequence of digits, one digit with the next (or, if the digit is the last, the first digit in the sequence). The digits that are the same as the next digit, are added together. Do that for a very large number.\n\n\n\n1122 produces a sum of 3 (1 + 2) because the first digit (1) matches the second digit and the third digit (2) matches the fourth digit.\n1111 produces 4 because each digit (all 1) matches the next.\n1234 produces 0 because no digit matches the next.\n91212129 produces 9 because the only digit that matches the next one is the last digit, 9.\n\nConstruct the test-cases:\n\nexample &lt;- c(\"1122\", \"1111\", \"1234\", \"91212129\")\n\nWhy a character vector? The input for the actual task might technically be a number. But it is so huge that we do not want to handle it as such.\nWe split the input, and convert to a numeric vector. Next that vector is shiftet to the right, placing the last value as the first, the first as the second etc. Then we compare those two vectors, and use that as a boolean index to the values.\n\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.5.1\n\n\nWarning: package 'tibble' was built under R version 4.5.1\n\n\nWarning: package 'purrr' was built under R version 4.5.1\n\n\nWarning: package 'stringr' was built under R version 4.5.1\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ncaptcha &lt;- function(input){\n  input &lt;- str_split_1(input, \"\") |&gt; as.numeric()\n  input_shifted &lt;- c(input[length(input)], input[2:length(input)-1])\n  sum(input[input == input_shifted])\n}\n\nTestning:\n\ncaptcha(example[4])\n\n[1] 9\n\n\nIt works.\n\n\n\nRead in the input:\n\ninput &lt;- readLines(\"data/day-01-input.txt\")\n\nUse it as input to the function:\n\ncaptcha(input)\n\n[1] 1171\n\n\nFirst star!\n\n\n\n\nNext we need to shift the vector even more. 50% in fact. This requires a new captcha function:\n\nnext_captcha &lt;- function(input){\n    input &lt;- str_split_1(input, \"\") |&gt; as.numeric()\n    len &lt;- length(input)\n    input_shifted &lt;- c(input[(len/2+1):len], input[1:(len/2)])\n    sum(input[input == input_shifted])\n  }\n\n\n\n\n1212 produces 6: the list contains 4 items, and all four digits match the digit 2 items ahead.\n1221 produces 0, because every comparison is between a 1 and a 2.\n123425 produces 4, because both 2s match each other, but no other digit has a match.\n123123 produces 12.\n12131415 produces 4.\n\nSetting up example data:\n\nexample &lt;- c(\"1212\", \"1221\", \"123425\", \"123123\", \"12131415\")\n\nTesting:\n\nnext_captcha(example[2])\n\n[1] 0\n\n\n\n\n\n\nnext_captcha(input)\n\n[1] 1024\n\n\nDone 🎄"
  },
  {
    "objectID": "aoc2015/forside.html",
    "href": "aoc2015/forside.html",
    "title": "Untitled",
    "section": "",
    "text": "library(gt)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n# Lav et data frame med årene som rækker\ndf &lt;- data.frame(År = 2015:2024)\n\n# Tilføj kolonner for dagene 1–25\nfor (d in 1:25) {\n  df[[as.character(d)]] &lt;- \"🎅\"  # eller \"\" hvis du vil have tomme felter\n}\n\n# Lav en gt-tabel\ndf %&gt;%\n  gt(rowname_col = \"År\") %&gt;%\n  tab_header(\n    title = \"Julekalender-tabel\",\n    subtitle = \"Årene 2015–2024 og dagene 1–25\"\n  )\n\n\n\n\n\n\n\nJulekalender-tabel\n\n\nÅrene 2015–2024 og dagene 1–25\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n\n2015\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n\n\n2016\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n\n\n2017\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n\n\n2018\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n\n\n2019\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n\n\n2020\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n\n\n2021\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n\n\n2022\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n\n\n2023\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n\n\n2024\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅\n🎅"
  },
  {
    "objectID": "aoc2015/day-02.html",
    "href": "aoc2015/day-02.html",
    "title": "Advent of Code 2015",
    "section": "",
    "text": "The total area of the box - we need to get the three pairwise products of width, length and height. The sum of that should be multiplied by 2. And the smallest area should be added.\nTwo tests:\n\ntest_1 &lt;- c(2,3,4)\ntest_2 &lt;- c(1,1,10)\n\nWe can get all the pairwise products using combn:\n\n(x &lt;- combn(test_1, 2, prod))\n\n[1]  6  8 12\n\n\nThe sum should be doubled, and the smallest value added:\n\n2*sum(x) + min(x)\n\n[1] 58\n\n\nThat appears to be correct. Lets make a function:\n\narea &lt;- function(x){\n  x &lt;- combn(x, 2, prod)\n  2*sum(x) + min(x)\n}\n\nIt also returns the correct result for test_2:\n\narea(test_2)\n\n[1] 43\n\n\nDownload the input, read it in, convert it to a tibble, split on “x”, and coerce to numeric:\n\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.5.1\n\n\nWarning: package 'tibble' was built under R version 4.5.1\n\n\nWarning: package 'purrr' was built under R version 4.5.1\n\n\nWarning: package 'stringr' was built under R version 4.5.1\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ninput &lt;- readLines(\"data/day-02-input.txt\") %&gt;% \n  as_tibble() %&gt;% \n  mutate(dimensions = map(value, str_split_1, \"x\")) %&gt;% \n  transmute(dimensions = map(dimensions, as.numeric))\n\nNow map the area function on the list column, unnest and summarise to get the sum:\n\ninput %&gt;% \n  transmute(area = map(dimensions, area)) %&gt;% \n  unnest(area) %&gt;% \n  summarise(svar = sum(area))\n\n# A tibble: 1 × 1\n     svar\n    &lt;dbl&gt;\n1 1588178\n\n\nNeat."
  },
  {
    "objectID": "aoc2015/day-02.html#wrapping-packages.",
    "href": "aoc2015/day-02.html#wrapping-packages.",
    "title": "Advent of Code 2015",
    "section": "",
    "text": "The total area of the box - we need to get the three pairwise products of width, length and height. The sum of that should be multiplied by 2. And the smallest area should be added.\nTwo tests:\n\ntest_1 &lt;- c(2,3,4)\ntest_2 &lt;- c(1,1,10)\n\nWe can get all the pairwise products using combn:\n\n(x &lt;- combn(test_1, 2, prod))\n\n[1]  6  8 12\n\n\nThe sum should be doubled, and the smallest value added:\n\n2*sum(x) + min(x)\n\n[1] 58\n\n\nThat appears to be correct. Lets make a function:\n\narea &lt;- function(x){\n  x &lt;- combn(x, 2, prod)\n  2*sum(x) + min(x)\n}\n\nIt also returns the correct result for test_2:\n\narea(test_2)\n\n[1] 43\n\n\nDownload the input, read it in, convert it to a tibble, split on “x”, and coerce to numeric:\n\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.5.1\n\n\nWarning: package 'tibble' was built under R version 4.5.1\n\n\nWarning: package 'purrr' was built under R version 4.5.1\n\n\nWarning: package 'stringr' was built under R version 4.5.1\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ninput &lt;- readLines(\"data/day-02-input.txt\") %&gt;% \n  as_tibble() %&gt;% \n  mutate(dimensions = map(value, str_split_1, \"x\")) %&gt;% \n  transmute(dimensions = map(dimensions, as.numeric))\n\nNow map the area function on the list column, unnest and summarise to get the sum:\n\ninput %&gt;% \n  transmute(area = map(dimensions, area)) %&gt;% \n  unnest(area) %&gt;% \n  summarise(svar = sum(area))\n\n# A tibble: 1 × 1\n     svar\n    &lt;dbl&gt;\n1 1588178\n\n\nNeat."
  },
  {
    "objectID": "aoc2015/day-02.html#task-2",
    "href": "aoc2015/day-02.html#task-2",
    "title": "Advent of Code 2015",
    "section": "Task 2",
    "text": "Task 2\nNow we need the ribbon needed in total. Both around the package, and for the bow.\nThe length need for the wrapping is the sum of all three dimensions, minus the largest value. And multiply by 2:\nWe write a function for that:\n\nwrap &lt;- function(x){\n  2*(sum(x) - max(x))\n}\n\nThen theres the ribbon. For some undisclosed reason, that is simply the product of the dimensions. We’re not going to write a function for that.\nWe already have the input with a list column, dimensions, with numericial vectors.\nWe mutate two new columns into existence, the ribbon is the product, the wrap is found using our function from before:\n\ninput &lt;- input %&gt;% \n  mutate(ribbon = map(dimensions, prod)) %&gt;% \n  mutate(wrap = map(dimensions, wrap))\ninput\n\n# A tibble: 1,000 × 3\n   dimensions ribbon    wrap     \n   &lt;list&gt;     &lt;list&gt;    &lt;list&gt;   \n 1 &lt;dbl [3]&gt;  &lt;dbl [1]&gt; &lt;dbl [1]&gt;\n 2 &lt;dbl [3]&gt;  &lt;dbl [1]&gt; &lt;dbl [1]&gt;\n 3 &lt;dbl [3]&gt;  &lt;dbl [1]&gt; &lt;dbl [1]&gt;\n 4 &lt;dbl [3]&gt;  &lt;dbl [1]&gt; &lt;dbl [1]&gt;\n 5 &lt;dbl [3]&gt;  &lt;dbl [1]&gt; &lt;dbl [1]&gt;\n 6 &lt;dbl [3]&gt;  &lt;dbl [1]&gt; &lt;dbl [1]&gt;\n 7 &lt;dbl [3]&gt;  &lt;dbl [1]&gt; &lt;dbl [1]&gt;\n 8 &lt;dbl [3]&gt;  &lt;dbl [1]&gt; &lt;dbl [1]&gt;\n 9 &lt;dbl [3]&gt;  &lt;dbl [1]&gt; &lt;dbl [1]&gt;\n10 &lt;dbl [3]&gt;  &lt;dbl [1]&gt; &lt;dbl [1]&gt;\n# ℹ 990 more rows\n\n\nUnnest those, add, and summarise:\n\ninput %&gt;% \n  unnest(c(ribbon, wrap)) %&gt;% \n  transmute(sub_tot = ribbon + wrap) %&gt;% \n  summarise(answer = sum(sub_tot))\n\n# A tibble: 1 × 1\n   answer\n    &lt;dbl&gt;\n1 3783758\n\n\nDone."
  },
  {
    "objectID": "aoc2015/dag4.html",
    "href": "aoc2015/dag4.html",
    "title": "Advent of Code 2015",
    "section": "",
    "text": "We have some input to an MD5 hash algorithm.\nIt consist of some padding, which is provide, preprended to a number in decimal.\nWe now need to find the lowest positive integer, with no leading zeroes, that results in a hash that starts with at least five zeroes.\nWe use a library to get access to an MD5 function:\nlibrary(openssl)\n\nLinking to: OpenSSL 3.4.1 11 Feb 2025\nAnd test that\ntest_hash &lt;- md5(\"abcdef609043\")\nStarts with “00000”:\nstartsWith(md5(\"abcdef609043\"), \"00000\")\n\n[1] TRUE\nCool, the md5 function we get from openssl actually works as expected.\nWe write a function, that checks if a given integer, x, padded with pad, returns a result starting with n zeroes:\nsolution &lt;- function(x, pad = \"abcdef\", n = 5){\n  startsWith(md5(paste0(pad,x)), paste0(rep(0,n), collapse = \"\"))\n}\nThe input we are given for padding is:\npad &lt;- \"iwrupvqb\"\nAnd we can now find the answer by bruteforcing:\nres &lt;- FALSE\ni &lt;- 0\nwhile(!res){\n  res &lt;- solution(i, pad = pad, n = 5 )\n  if(res){\n    answer &lt;- i}\n  i &lt;- i+1\n}\nanswer\nBut we are not going to show it here."
  },
  {
    "objectID": "aoc2015/dag4.html#part-2.",
    "href": "aoc2015/dag4.html#part-2.",
    "title": "Advent of Code 2015",
    "section": "Part 2.",
    "text": "Part 2.\nSame problem. Now with six zeroes instead of five.\n\nres &lt;- FALSE\ni &lt;- 0\nwhile(!res){\n  res &lt;- solution(i, pad = pad, n = 6 )\n  if(res){\n    answer &lt;- i}\n  i &lt;- i+1\n}\nanswer\n\nWe dont show that either. 9958218 var svaret. Det tager tid…"
  },
  {
    "objectID": "aoc2015/day-01.html",
    "href": "aoc2015/day-01.html",
    "title": "Advent of Code 2015",
    "section": "",
    "text": "Task: https://adventofcode.com/2015/day/1\nWe have some text strings containing opening and closing parentheses.\nOpening, ( indicates that we go one level up in an elevator. ) that we go one level down.\nWe want to determine which floor we end on. This is equivalent to taking the sum of 1s (if the character is “(”), and -1s (if the character is “(”).\nWe can split a test string in individual characters:\n\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.5.1\n\n\nWarning: package 'tibble' was built under R version 4.5.1\n\n\nWarning: package 'purrr' was built under R version 4.5.1\n\n\nWarning: package 'stringr' was built under R version 4.5.1\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ntest &lt;- \"))(((((\"\nstr_split_1(test,\"\")\n\n[1] \")\" \")\" \"(\" \"(\" \"(\" \"(\" \"(\"\n\n\nIf we make a scheme in a named numeric vector, we can use the split string to index that scheme, and get 1s and -1s:\n\nscheme &lt;- c(\"(\" = 1, \")\" = -1)\nscheme[str_split_1(test,\"\")]\n\n )  )  (  (  (  (  ( \n-1 -1  1  1  1  1  1 \n\n\nAnd we can now sum all those numbers:\n\nsum(scheme[str_split_1(test,\"\")])\n\n[1] 3\n\n\nAccording to the site, this was the correct result!.\nNow read in the input, saved locally.\n\ninput &lt;- readLines(\"data/day-01-input.txt\")\n\nWarning in readLines(\"data/day-01-input.txt\"): incomplete final line found on\n'data/day-01-input.txt'\n\n\nRemember to replace “test” with “input”:\n\nsum(scheme[str_split_1(input,\"\")])\n\n[1] 280\n\n\nCorrect result!\nNow task 2:\nWhich parenthesis is the first that lead Santa to level -1 in the building?\nWhen we have the instructions (1s and -1s), we need the cumulative sum, and the first index that have a sum of -1.\nSo: In a horrible nested expression: Split, use that as index for the named vector, get the cumulative sum, get the indices matching -1, and returning the minimum value:\n\nmin(which(cumsum(scheme[str_split_1(input, \"\")]) == -1))\n\n[1] 1797\n\n\nDone."
  },
  {
    "objectID": "aoc2015/day-03.html",
    "href": "aoc2015/day-03.html",
    "title": "Advent of Code 2015",
    "section": "",
    "text": "Handling an infinitely large matrix? Nope!\nTibble with coordinates? Yes!\nBased on the last positino we can add a row, based on the drunken-elfo-instructions. If we want to know how many presents have been delivered to a given positon, we count all the occurences of that position in the tibble.\nAs always, because I speak tidy:\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.5.1\n\n\nWarning: package 'tibble' was built under R version 4.5.1\n\n\nWarning: package 'purrr' was built under R version 4.5.1\n\n\nWarning: package 'stringr' was built under R version 4.5.1\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\nWe make a tibble, which is not actually a grid, but a tidy grid:\ngrid &lt;- tibble(X = 0, Y = 0)\nX is east/west, Y is north/south. If we go north, we add 1 to the Y-value of the current position, -1 if going south. And do not change the X-value. If we go east, we add 1 to the X-value. You get the point.\nWe have an awful lot of instructions, and make a named list with what should happen with the (X,Y) values of the current position, when we update it.\nscheme &lt;- list(\"^\" = c(X = 0, Y = 1),\n               \"v\" = c(X = 0, Y = -1),\n               \"&lt;\" = c(X = -1, Y = 0),\n               \"&gt;\" = c(X = 1, Y = 0))\nWe write a function to do that - it makes mapping easier:\ncoord &lt;- function(x){\n  scheme[[x]]\n}\nIt takes input, and returns the vector with the corresponding changes in X and Y.\nBut we do not actually need to update anything. We just need to register all the changes, and can find a given position by adding up all the changes - we do that by taking the cumulative sum.\nWe have some examples:\ntest &lt;- \"^v^v^v^v^v\"\nWe split it\ntest %&gt;% str_split_1(\"\") %&gt;% \n  as_tibble() %&gt;%   \n  transmute(coord = map(value, coord)) %&gt;% \n  unnest_wider(coord)\n\n# A tibble: 10 × 2\n       X     Y\n   &lt;dbl&gt; &lt;dbl&gt;\n 1     0     1\n 2     0    -1\n 3     0     1\n 4     0    -1\n 5     0     1\n 6     0    -1\n 7     0     1\n 8     0    -1\n 9     0     1\n10     0    -1\nWe are missing the first postion, (0,0). So let us add that:\nrbind(grid, test %&gt;% \n  str_split_1(\"\") %&gt;% \n  as_tibble() %&gt;%   \n  transmute(coord = map(value, coord)) %&gt;% \n  unnest_wider(coord)\n )\n\n# A tibble: 11 × 2\n       X     Y\n   &lt;dbl&gt; &lt;dbl&gt;\n 1     0     0\n 2     0     1\n 3     0    -1\n 4     0     1\n 5     0    -1\n 6     0     1\n 7     0    -1\n 8     0     1\n 9     0    -1\n10     0     1\n11     0    -1\nThis is the start position, and all changes. So now we take the cumulative sums:\nrbind(grid, test %&gt;% \n  str_split_1(\"\") %&gt;% \n  as_tibble() %&gt;%   \n  transmute(coord = map(value, coord)) %&gt;% \n  unnest_wider(coord)\n ) %&gt;% \n  transmute(x = cumsum(X), y = cumsum(Y)) \n\n# A tibble: 11 × 2\n       x     y\n   &lt;dbl&gt; &lt;dbl&gt;\n 1     0     0\n 2     0     1\n 3     0     0\n 4     0     1\n 5     0     0\n 6     0     1\n 7     0     0\n 8     0     1\n 9     0     0\n10     0     1\n11     0     0\nWe now have the grid-coordinates, and simply needs to count how many times each coordinate has been visited. The number of rows in that result is the number of individual coordinates - and that is the answer we are looking for:\nrbind(grid, test %&gt;% \n  str_split_1(\"\") %&gt;% \n  as_tibble() %&gt;%   \n  transmute(coord = map(value, coord)) %&gt;% \n  unnest_wider(coord)\n ) %&gt;% \n  transmute(x = cumsum(X), y = cumsum(Y)) %&gt;% \n  count(x, y) %&gt;% nrow()\n\n[1] 2\nThat gives us the answer we are told is correct for the test.\nNow we simply have to do the same for the input file:\ninput &lt;- readLines(\"../aoc2015/data/day-03-input.txt\") \n\nWarning in readLines(\"../aoc2015/data/day-03-input.txt\"): incomplete final line\nfound on '../aoc2015/data/day-03-input.txt'\n\nrbind(grid, input %&gt;% \n  str_split_1(\"\") %&gt;% \n  as_tibble() %&gt;%   \n  transmute(coord = map(value, coord)) %&gt;% \n  unnest_wider(coord)\n ) %&gt;% \n  transmute(x = cumsum(X), y = cumsum(Y)) %&gt;% \n  count(x, y) %&gt;% nrow()\n\n[1] 2592\nNice."
  },
  {
    "objectID": "aoc2015/day-03.html#task-2",
    "href": "aoc2015/day-03.html#task-2",
    "title": "Advent of Code 2015",
    "section": "Task 2",
    "text": "Task 2\nRobo-santa and Santa are going to share the distribution. Elfo is still drunk.\nWe need to split up the input in two. Odd-numbered instructions go to Santa, even-numbered to Robo-santa.\nRead in data, add rownumbers, and split into two:\n\ninput &lt;- input %&gt;% \n  str_split_1(\"\") %&gt;% \n  as_tibble() %&gt;% \n  mutate(r_num = 1:nrow(.))\n\ninput_santa &lt;- input %&gt;% \n  filter(r_num %% 2 == 1)\ninput_robo_santa &lt;- input %&gt;% \n  filter(r_num %% 2 != 1)\n\nRepeat the exercise from above for the two versions of Santa.\n\nsanta_grid &lt;- rbind(grid, input_santa %&gt;% \n                          transmute(coord = map(value, coord)) %&gt;% \n                          unnest_wider(coord)) %&gt;% \n                          transmute(x = cumsum(X), \n                                    y = cumsum(Y)) \n\nrobo_grid &lt;- rbind(grid, input_robo_santa %&gt;% \n                          transmute(coord = map(value, coord)) %&gt;% \n                          unnest_wider(coord)) %&gt;% \n                          transmute(x = cumsum(X), \n                                    y = cumsum(Y)) \n\nWe then combine the two grids:\n\nrbind(santa_grid, robo_grid) %&gt;% \n  count(x, y) %&gt;% \n  nrow()\n\n[1] 2360\n\n\nDone."
  },
  {
    "objectID": "aoc2016/day-02.html",
    "href": "aoc2016/day-02.html",
    "title": "Advent of Code 2016",
    "section": "",
    "text": "A tale of two lookup tables.\n\nlibrary(stringr)\n\nWarning: package 'stringr' was built under R version 4.5.1\n\n\n\n\nOn a keypad, start somewhere, follow instructions moving around. First set of instructions give the first value. Second set of instructions, starting at the first value from the previous set of instructions, give the second value. Continue until you run out of instructions.\n\n\nThis the the keypad. We start at 5, instructions “UU” moves up to “2”. The second “U” does not change anything, because we cannot go up from that\n123 456 789\nWe make a lookup table. Given a position and an instruction, what is the new position?\n\nlut &lt;- c( 1, 4, 1, 2,\n 2, 5, 1, 3,\n 3, 6, 2, 3,\n 1, 7, 4, 5,\n 2, 8, 4, 6,\n 3, 9, 5, 6,\n 4, 7, 7, 8,\n 5, 8, 7, 9,\n 6, 9, 8, 9) |&gt; \n  matrix(nrow = 9, byrow = T,\n    dimnames = list(pos = c(1:9), instruction = c(\"U\", \"D\", \"L\", \"R\")))\nlut\n\n   instruction\npos U D L R\n  1 1 4 1 2\n  2 2 5 1 3\n  3 3 6 2 3\n  4 1 7 4 5\n  5 2 8 4 6\n  6 3 9 5 6\n  7 4 7 7 8\n  8 5 8 7 9\n  9 6 9 8 9\n\n\nAnd a function for updating the position:\n\nnew_pos &lt;- function(pos, instruction){\n  lut[pos, instruction]\n}\n\nConstruct the instruction set:\n\ninput &lt;- c(\"ULL\", \"RRDDD\", \"LURDL\", \"UUUUD\")\n\nSplit and save in list:\n\ninput &lt;-   str_split(input, \"\")\n\nWrite a function that loops through the length of the instruction set, and in an inner loop loops through the instructions in each element.\n\nanswer &lt;- numeric()\npos &lt;- 5\nfor(i in 1:length(input)){\n  for(j in input[[i]]){\n    pos &lt;- new_pos(pos, j)\n  }\nanswer[i] &lt;- pos\n}\n\nanswer &lt;- paste0(answer, collapse = \"\")\n\nReturns the correct answer!\n\n\n\nNow read in the complete instruction set:\n\ninput &lt;- readLines(\"data/02-input.txt\")\ninput &lt;-   str_split(input, \"\")\n\nanswer &lt;- numeric()\npos &lt;- 5\nfor(i in 1:length(input)){\n  for(j in input[[i]]){\n    pos &lt;- new_pos(pos, j)\n  }\nanswer[i] &lt;- pos\n}\n\nanswer &lt;- paste0(answer, collapse = \"\")\n\n\n\n\n\nBasically the exact same task. But with different layout of keypad.\n\n\nNew lookup-table:\n\nlut &lt;- c(\"1\",   \"3\",    \"1\",    \"1\",\n\"2\",    \"6\",    \"2\",    \"3\",\n\"1\",    \"7\",    \"2\",    \"4\",\n\"4\",    \"8\",    \"3\",    \"4\",\n\"5\",    \"5\",    \"5\",    \"6\",\n\"2\",    \"A\",    \"5\",    \"7\",\n\"3\",    \"B\",    \"6\",    \"8\",\n\"4\",    \"C\",    \"7\",    \"9\",\n\"9\",    \"9\",    \"8\",    \"9\",\n\"6\",    \"A\",    \"A\",    \"B\",\n\"7\",    \"D\",    \"A\",    \"C\",\n\"8\",    \"C\",    \"B\",    \"C\",\n\"B\",    \"D\",    \"D\",    \"D\") |&gt; \n    matrix(nrow = 13, byrow = T,\n    dimnames = list(pos = c(as.character(1:9), LETTERS[1:4]), instruks = c(\"U\", \"D\", \"L\", \"R\")))\n\nlut\n\n   instruks\npos U   D   L   R  \n  1 \"1\" \"3\" \"1\" \"1\"\n  2 \"2\" \"6\" \"2\" \"3\"\n  3 \"1\" \"7\" \"2\" \"4\"\n  4 \"4\" \"8\" \"3\" \"4\"\n  5 \"5\" \"5\" \"5\" \"6\"\n  6 \"2\" \"A\" \"5\" \"7\"\n  7 \"3\" \"B\" \"6\" \"8\"\n  8 \"4\" \"C\" \"7\" \"9\"\n  9 \"9\" \"9\" \"8\" \"9\"\n  A \"6\" \"A\" \"A\" \"B\"\n  B \"7\" \"D\" \"A\" \"C\"\n  C \"8\" \"C\" \"B\" \"C\"\n  D \"B\" \"D\" \"D\" \"D\"\n\n\nThe test input:\n\ninput &lt;- c(\"ULL\", \"RRDDD\", \"LURDL\", \"UUUUD\")\ninput &lt;-   str_split(input, \"\")\n\nAnd apply the same procedure. But remember that we now have characters on the keypad.\n\nanswer &lt;- character()\npos &lt;- \"5\"\nfor(i in 1:length(input)){\n  for(j in input[[i]]){\n    pos &lt;- new_pos(pos, j)\n  }\nanswer[i] &lt;- pos\n}\n\nanswer &lt;- paste0(answer, collapse = \"\")\nanswer\n\n[1] \"5DB3\"\n\n\nNice\n\n\n\nThe exact same procedure, now with the full input:\n\ninput &lt;- readLines(\"data/02-input.txt\")\ninput &lt;-   str_split(input, \"\")\n\n\nanswer &lt;- character()\npos &lt;- \"5\"\nfor(i in 1:length(input)){\n  for(j in input[[i]]){\n    pos &lt;- new_pos(pos, j)\n  }\nanswer[i] &lt;- pos\n}\n\nanswer &lt;- paste0(answer, collapse = \"\")\n\nDone 🎄"
  },
  {
    "objectID": "aoc2016/day-02.html#lookup-toilets",
    "href": "aoc2016/day-02.html#lookup-toilets",
    "title": "Advent of Code 2016",
    "section": "",
    "text": "A tale of two lookup tables.\n\nlibrary(stringr)\n\nWarning: package 'stringr' was built under R version 4.5.1\n\n\n\n\nOn a keypad, start somewhere, follow instructions moving around. First set of instructions give the first value. Second set of instructions, starting at the first value from the previous set of instructions, give the second value. Continue until you run out of instructions.\n\n\nThis the the keypad. We start at 5, instructions “UU” moves up to “2”. The second “U” does not change anything, because we cannot go up from that\n123 456 789\nWe make a lookup table. Given a position and an instruction, what is the new position?\n\nlut &lt;- c( 1, 4, 1, 2,\n 2, 5, 1, 3,\n 3, 6, 2, 3,\n 1, 7, 4, 5,\n 2, 8, 4, 6,\n 3, 9, 5, 6,\n 4, 7, 7, 8,\n 5, 8, 7, 9,\n 6, 9, 8, 9) |&gt; \n  matrix(nrow = 9, byrow = T,\n    dimnames = list(pos = c(1:9), instruction = c(\"U\", \"D\", \"L\", \"R\")))\nlut\n\n   instruction\npos U D L R\n  1 1 4 1 2\n  2 2 5 1 3\n  3 3 6 2 3\n  4 1 7 4 5\n  5 2 8 4 6\n  6 3 9 5 6\n  7 4 7 7 8\n  8 5 8 7 9\n  9 6 9 8 9\n\n\nAnd a function for updating the position:\n\nnew_pos &lt;- function(pos, instruction){\n  lut[pos, instruction]\n}\n\nConstruct the instruction set:\n\ninput &lt;- c(\"ULL\", \"RRDDD\", \"LURDL\", \"UUUUD\")\n\nSplit and save in list:\n\ninput &lt;-   str_split(input, \"\")\n\nWrite a function that loops through the length of the instruction set, and in an inner loop loops through the instructions in each element.\n\nanswer &lt;- numeric()\npos &lt;- 5\nfor(i in 1:length(input)){\n  for(j in input[[i]]){\n    pos &lt;- new_pos(pos, j)\n  }\nanswer[i] &lt;- pos\n}\n\nanswer &lt;- paste0(answer, collapse = \"\")\n\nReturns the correct answer!\n\n\n\nNow read in the complete instruction set:\n\ninput &lt;- readLines(\"data/02-input.txt\")\ninput &lt;-   str_split(input, \"\")\n\nanswer &lt;- numeric()\npos &lt;- 5\nfor(i in 1:length(input)){\n  for(j in input[[i]]){\n    pos &lt;- new_pos(pos, j)\n  }\nanswer[i] &lt;- pos\n}\n\nanswer &lt;- paste0(answer, collapse = \"\")\n\n\n\n\n\nBasically the exact same task. But with different layout of keypad.\n\n\nNew lookup-table:\n\nlut &lt;- c(\"1\",   \"3\",    \"1\",    \"1\",\n\"2\",    \"6\",    \"2\",    \"3\",\n\"1\",    \"7\",    \"2\",    \"4\",\n\"4\",    \"8\",    \"3\",    \"4\",\n\"5\",    \"5\",    \"5\",    \"6\",\n\"2\",    \"A\",    \"5\",    \"7\",\n\"3\",    \"B\",    \"6\",    \"8\",\n\"4\",    \"C\",    \"7\",    \"9\",\n\"9\",    \"9\",    \"8\",    \"9\",\n\"6\",    \"A\",    \"A\",    \"B\",\n\"7\",    \"D\",    \"A\",    \"C\",\n\"8\",    \"C\",    \"B\",    \"C\",\n\"B\",    \"D\",    \"D\",    \"D\") |&gt; \n    matrix(nrow = 13, byrow = T,\n    dimnames = list(pos = c(as.character(1:9), LETTERS[1:4]), instruks = c(\"U\", \"D\", \"L\", \"R\")))\n\nlut\n\n   instruks\npos U   D   L   R  \n  1 \"1\" \"3\" \"1\" \"1\"\n  2 \"2\" \"6\" \"2\" \"3\"\n  3 \"1\" \"7\" \"2\" \"4\"\n  4 \"4\" \"8\" \"3\" \"4\"\n  5 \"5\" \"5\" \"5\" \"6\"\n  6 \"2\" \"A\" \"5\" \"7\"\n  7 \"3\" \"B\" \"6\" \"8\"\n  8 \"4\" \"C\" \"7\" \"9\"\n  9 \"9\" \"9\" \"8\" \"9\"\n  A \"6\" \"A\" \"A\" \"B\"\n  B \"7\" \"D\" \"A\" \"C\"\n  C \"8\" \"C\" \"B\" \"C\"\n  D \"B\" \"D\" \"D\" \"D\"\n\n\nThe test input:\n\ninput &lt;- c(\"ULL\", \"RRDDD\", \"LURDL\", \"UUUUD\")\ninput &lt;-   str_split(input, \"\")\n\nAnd apply the same procedure. But remember that we now have characters on the keypad.\n\nanswer &lt;- character()\npos &lt;- \"5\"\nfor(i in 1:length(input)){\n  for(j in input[[i]]){\n    pos &lt;- new_pos(pos, j)\n  }\nanswer[i] &lt;- pos\n}\n\nanswer &lt;- paste0(answer, collapse = \"\")\nanswer\n\n[1] \"5DB3\"\n\n\nNice\n\n\n\nThe exact same procedure, now with the full input:\n\ninput &lt;- readLines(\"data/02-input.txt\")\ninput &lt;-   str_split(input, \"\")\n\n\nanswer &lt;- character()\npos &lt;- \"5\"\nfor(i in 1:length(input)){\n  for(j in input[[i]]){\n    pos &lt;- new_pos(pos, j)\n  }\nanswer[i] &lt;- pos\n}\n\nanswer &lt;- paste0(answer, collapse = \"\")\n\nDone 🎄"
  },
  {
    "objectID": "aoc2024/day-01.html",
    "href": "aoc2024/day-01.html",
    "title": "Advent of Code 2024",
    "section": "",
    "text": "As always:\n\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.5.1\n\n\nWarning: package 'tibble' was built under R version 4.5.1\n\n\nWarning: package 'purrr' was built under R version 4.5.1\n\n\nWarning: package 'stringr' was built under R version 4.5.1\n\n\n\n\n\n\nLike we are used to in Project Euler we get a small example, and the result, in order for us to be able to check our method.\n\nexample &lt;- tribble(~list1, ~list2,\n3,   4,\n4,   3,\n2,   5,\n1,   3,\n3,   9,\n3,   3)\n\nThis is simple, as it should be on the first day.\nSort the two vectors, direction does not matter, and calculate the absolute difference, then add everything together:\n\nsum(abs(sort(example$list1) - sort(example$list2)))\n\n[1] 11\n\n\n\n\n\nDownloading the lists computationally is a bit cumbersome. I’m simply saving it directly to disk and reading it:\n\ndata &lt;- read_delim(\"data/day-01-input.txt\", delim = \"   \", col_names = F)\n\nRows: 1000 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"   \"\ndbl (2): X1, X2\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nsum(abs(sort(data$X1) - sort(data$X2)))\n\n[1] 2904518\n\n\n\n\n\n\nCount how many times the numbers in list 1 occurs in list 2, multiply the numbers in list 1 with the count from list 2, and sum.\n\n\n\nexample %&gt;% \n  count(list2) %&gt;% \n  right_join(example, by = c(\"list2\" = \"list1\")) %&gt;% \n  transmute(sim_score = n*list2) %&gt;% \n  summarise(answer = sum(sim_score, na.rm = TRUE))\n\n# A tibble: 1 × 1\n  answer\n   &lt;dbl&gt;\n1     31\n\n\nCount the occurences of numbers in list 2, right join - due to the flow in the pipe on example. Remember to join on the correct columns. Transmute to get the count multiplied by the number. Do not confuse yourself that the column is now called list2. And summarise. Use na.rm = T, to account for missing matches resulting in NA values.\nCorrect answer - the method is working.\n\n\n\n\ndata %&gt;% \n  count(X2) %&gt;% \n  right_join(data, by = c(\"X2\" = \"X1\")) %&gt;% \n  transmute(sim_score = n*X2) %&gt;% \n  summarise(answer = sum(sim_score, na.rm = TRUE))\n\n# A tibble: 1 × 1\n    answer\n     &lt;dbl&gt;\n1 18650129\n\n\nRemember to change column names, and to join on the actual data, rather than on example.\nDone 🎄"
  },
  {
    "objectID": "aoc2024/day-01.html#comparison-of-lists---or-vectors",
    "href": "aoc2024/day-01.html#comparison-of-lists---or-vectors",
    "title": "Advent of Code 2024",
    "section": "",
    "text": "As always:\n\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.5.1\n\n\nWarning: package 'tibble' was built under R version 4.5.1\n\n\nWarning: package 'purrr' was built under R version 4.5.1\n\n\nWarning: package 'stringr' was built under R version 4.5.1\n\n\n\n\n\n\nLike we are used to in Project Euler we get a small example, and the result, in order for us to be able to check our method.\n\nexample &lt;- tribble(~list1, ~list2,\n3,   4,\n4,   3,\n2,   5,\n1,   3,\n3,   9,\n3,   3)\n\nThis is simple, as it should be on the first day.\nSort the two vectors, direction does not matter, and calculate the absolute difference, then add everything together:\n\nsum(abs(sort(example$list1) - sort(example$list2)))\n\n[1] 11\n\n\n\n\n\nDownloading the lists computationally is a bit cumbersome. I’m simply saving it directly to disk and reading it:\n\ndata &lt;- read_delim(\"data/day-01-input.txt\", delim = \"   \", col_names = F)\n\nRows: 1000 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"   \"\ndbl (2): X1, X2\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nsum(abs(sort(data$X1) - sort(data$X2)))\n\n[1] 2904518\n\n\n\n\n\n\nCount how many times the numbers in list 1 occurs in list 2, multiply the numbers in list 1 with the count from list 2, and sum.\n\n\n\nexample %&gt;% \n  count(list2) %&gt;% \n  right_join(example, by = c(\"list2\" = \"list1\")) %&gt;% \n  transmute(sim_score = n*list2) %&gt;% \n  summarise(answer = sum(sim_score, na.rm = TRUE))\n\n# A tibble: 1 × 1\n  answer\n   &lt;dbl&gt;\n1     31\n\n\nCount the occurences of numbers in list 2, right join - due to the flow in the pipe on example. Remember to join on the correct columns. Transmute to get the count multiplied by the number. Do not confuse yourself that the column is now called list2. And summarise. Use na.rm = T, to account for missing matches resulting in NA values.\nCorrect answer - the method is working.\n\n\n\n\ndata %&gt;% \n  count(X2) %&gt;% \n  right_join(data, by = c(\"X2\" = \"X1\")) %&gt;% \n  transmute(sim_score = n*X2) %&gt;% \n  summarise(answer = sum(sim_score, na.rm = TRUE))\n\n# A tibble: 1 × 1\n    answer\n     &lt;dbl&gt;\n1 18650129\n\n\nRemember to change column names, and to join on the actual data, rather than on example.\nDone 🎄"
  },
  {
    "objectID": "aoc2024/day-03.html",
    "href": "aoc2024/day-03.html",
    "title": "Advent of Code 2024",
    "section": "",
    "text": "This is an exercise in regular expressions, and datamanipulation.\nWe need to extract all parts of the input text matching the form “mul(123,456)”\nAs always:\n\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.5.1\n\n\nWarning: package 'tibble' was built under R version 4.5.1\n\n\nWarning: package 'purrr' was built under R version 4.5.1\n\n\nWarning: package 'stringr' was built under R version 4.5.1\n\n\nAnd read the data - again a local copy:\n\ninput &lt;- readLines(\"data/day-03-input.txt\") \n\nSo lets do that:\n\ninput &lt;- input %&gt;% as_tibble() %&gt;% \n  transmute(multiplications = str_extract_all(value, \"mul\\\\(\\\\d{1,3}\\\\,\\\\d{1,3}\\\\)\", simplify = F) ) %&gt;% \n  unnest(multiplications)\ninput\n\n# A tibble: 650 × 1\n   multiplications\n   &lt;chr&gt;          \n 1 mul(234,359)   \n 2 mul(260,344)   \n 3 mul(87,298)    \n 4 mul(407,173)   \n 5 mul(763,519)   \n 6 mul(258,409)   \n 7 mul(703,155)   \n 8 mul(423,685)   \n 9 mul(647,758)   \n10 mul(595,333)   \n# ℹ 640 more rows\n\n\nNext remove stuff:\n\ninput &lt;- input %&gt;%\n  mutate(multiplications = str_remove_all(multiplications, \"mul\\\\(|\\\\)\")) \ninput\n\n# A tibble: 650 × 1\n   multiplications\n   &lt;chr&gt;          \n 1 234,359        \n 2 260,344        \n 3 87,298         \n 4 407,173        \n 5 763,519        \n 6 258,409        \n 7 703,155        \n 8 423,685        \n 9 647,758        \n10 595,333        \n# ℹ 640 more rows\n\n\nSplit on “,”, coerce to numeric,\n\ninput &lt;- input %&gt;% \n    separate_wider_delim(multiplications, delim = \",\", names = c(\"factor_1\", \"factor_2\")) %&gt;% \n    mutate(across(everything(), as.numeric)) \n  \ninput\n\n# A tibble: 650 × 2\n   factor_1 factor_2\n      &lt;dbl&gt;    &lt;dbl&gt;\n 1      234      359\n 2      260      344\n 3       87      298\n 4      407      173\n 5      763      519\n 6      258      409\n 7      703      155\n 8      423      685\n 9      647      758\n10      595      333\n# ℹ 640 more rows\n\n\nFinally multiply and summarise to get the answer:\n\ninput %&gt;% \n  transmute(products = factor_1 * factor_2) %&gt;% \n  summarise(answer = sum(products))\n\n# A tibble: 1 × 1\n     answer\n      &lt;dbl&gt;\n1 164730528"
  },
  {
    "objectID": "aoc2024/day-03.html#regular-expressions",
    "href": "aoc2024/day-03.html#regular-expressions",
    "title": "Advent of Code 2024",
    "section": "",
    "text": "This is an exercise in regular expressions, and datamanipulation.\nWe need to extract all parts of the input text matching the form “mul(123,456)”\nAs always:\n\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.5.1\n\n\nWarning: package 'tibble' was built under R version 4.5.1\n\n\nWarning: package 'purrr' was built under R version 4.5.1\n\n\nWarning: package 'stringr' was built under R version 4.5.1\n\n\nAnd read the data - again a local copy:\n\ninput &lt;- readLines(\"data/day-03-input.txt\") \n\nSo lets do that:\n\ninput &lt;- input %&gt;% as_tibble() %&gt;% \n  transmute(multiplications = str_extract_all(value, \"mul\\\\(\\\\d{1,3}\\\\,\\\\d{1,3}\\\\)\", simplify = F) ) %&gt;% \n  unnest(multiplications)\ninput\n\n# A tibble: 650 × 1\n   multiplications\n   &lt;chr&gt;          \n 1 mul(234,359)   \n 2 mul(260,344)   \n 3 mul(87,298)    \n 4 mul(407,173)   \n 5 mul(763,519)   \n 6 mul(258,409)   \n 7 mul(703,155)   \n 8 mul(423,685)   \n 9 mul(647,758)   \n10 mul(595,333)   \n# ℹ 640 more rows\n\n\nNext remove stuff:\n\ninput &lt;- input %&gt;%\n  mutate(multiplications = str_remove_all(multiplications, \"mul\\\\(|\\\\)\")) \ninput\n\n# A tibble: 650 × 1\n   multiplications\n   &lt;chr&gt;          \n 1 234,359        \n 2 260,344        \n 3 87,298         \n 4 407,173        \n 5 763,519        \n 6 258,409        \n 7 703,155        \n 8 423,685        \n 9 647,758        \n10 595,333        \n# ℹ 640 more rows\n\n\nSplit on “,”, coerce to numeric,\n\ninput &lt;- input %&gt;% \n    separate_wider_delim(multiplications, delim = \",\", names = c(\"factor_1\", \"factor_2\")) %&gt;% \n    mutate(across(everything(), as.numeric)) \n  \ninput\n\n# A tibble: 650 × 2\n   factor_1 factor_2\n      &lt;dbl&gt;    &lt;dbl&gt;\n 1      234      359\n 2      260      344\n 3       87      298\n 4      407      173\n 5      763      519\n 6      258      409\n 7      703      155\n 8      423      685\n 9      647      758\n10      595      333\n# ℹ 640 more rows\n\n\nFinally multiply and summarise to get the answer:\n\ninput %&gt;% \n  transmute(products = factor_1 * factor_2) %&gt;% \n  summarise(answer = sum(products))\n\n# A tibble: 1 × 1\n     answer\n      &lt;dbl&gt;\n1 164730528"
  },
  {
    "objectID": "aoc2024/day-03.html#task-2",
    "href": "aoc2024/day-03.html#task-2",
    "title": "Advent of Code 2024",
    "section": "Task 2",
    "text": "Task 2\nNow it gets more complicated. There are instructions in the text. “do()” in the text indicates that all following multiplications should be executed. “don’t()” that all following multiplications should not.\nWe need to identify those as well.\nStart by reading in the data again, because assigning data back into the original is a bad idea…\n\ninput &lt;- readLines(\"data/day-03-input.txt\") \n\nNow we convert it to a tibble like before, but now we also extract the two different types of instructions:\n\ninput &lt;- input %&gt;% as_tibble() %&gt;% \n  transmute(instructions = str_extract_all(value, \"mul\\\\(\\\\d{1,3}\\\\,\\\\d{1,3}\\\\)|do\\\\(\\\\)|don\\\\'t\\\\(\\\\)\", simplify = F) ) %&gt;% \n  unnest(instructions)\ninput\n\n# A tibble: 713 × 1\n   instructions\n   &lt;chr&gt;       \n 1 mul(234,359)\n 2 mul(260,344)\n 3 mul(87,298) \n 4 mul(407,173)\n 5 mul(763,519)\n 6 mul(258,409)\n 7 mul(703,155)\n 8 mul(423,685)\n 9 mul(647,758)\n10 mul(595,333)\n# ℹ 703 more rows\n\n\nWe can’t see it here, but there are do’s and don’ts in the instructions column.\nThose needs to be separated out:\n\ninput &lt;- input %&gt;%\n  mutate(instruction = case_when(\n                              str_detect(instructions, \"do\") ~ instructions,\n                              .default = NA))\ninput\n\n# A tibble: 713 × 2\n   instructions instruction\n   &lt;chr&gt;        &lt;chr&gt;      \n 1 mul(234,359) &lt;NA&gt;       \n 2 mul(260,344) &lt;NA&gt;       \n 3 mul(87,298)  &lt;NA&gt;       \n 4 mul(407,173) &lt;NA&gt;       \n 5 mul(763,519) &lt;NA&gt;       \n 6 mul(258,409) &lt;NA&gt;       \n 7 mul(703,155) &lt;NA&gt;       \n 8 mul(423,685) &lt;NA&gt;       \n 9 mul(647,758) &lt;NA&gt;       \n10 mul(595,333) &lt;NA&gt;       \n# ℹ 703 more rows\n\n\nAgain - they are there…\nWhen we encounter a “do()” in the instruction column, all following multiplications should be executed, until we encounter a “don’t()”. So we fill down. We still have som NA’s at the top of the tibble, we replace those with “do()”\n\ninput &lt;- input  %&gt;% \n  fill(instruction, .direction=\"down\") %&gt;% \n  replace_na(list(instruction = \"do()\")) \ninput\n\n# A tibble: 713 × 2\n   instructions instruction\n   &lt;chr&gt;        &lt;chr&gt;      \n 1 mul(234,359) do()       \n 2 mul(260,344) do()       \n 3 mul(87,298)  do()       \n 4 mul(407,173) do()       \n 5 mul(763,519) do()       \n 6 mul(258,409) do()       \n 7 mul(703,155) do()       \n 8 mul(423,685) do()       \n 9 mul(647,758) do()       \n10 mul(595,333) do()       \n# ℹ 703 more rows\n\n\nWe are only interested in the multiplicaitons with “do()” in the instruction column - lets filter to get them:\n\ninput &lt;- input %&gt;% \n  filter(instruction != \"don't()\") %&gt;% \n  filter(str_starts(instructions, \"m\"))\n\nWe also need to get rid of those control-words in the instructions column.\nAnd now the rest is done as before:\n\ninput %&gt;% \n  mutate(instructions = str_remove_all(instructions, \"mul\\\\(|\\\\)\")) %&gt;% \n  separate_wider_delim(instructions, delim = \",\", names = c(\"factor_1\", \"factor_2\")) %&gt;% \n  mutate(across(everything(), as.numeric)) %&gt;% \n  transmute(products = factor_1 * factor_2) %&gt;% \n  summarise(answer = sum(products))\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `across(everything(), as.numeric)`.\nCaused by warning:\n! NAs introduced by coercion\n\n\n# A tibble: 1 × 1\n    answer\n     &lt;dbl&gt;\n1 70478672\n\n\nDone."
  }
]